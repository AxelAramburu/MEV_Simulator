"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveOrCreateATAs = exports.resolveOrCreateATA = void 0;
const spl_token_1 = require("@solana/spl-token");
const math_1 = require("../math");
const network_1 = require("./network");
const token_util_1 = require("./token-util");
const types_1 = require("./transactions/types");
/**
 * IMPORTANT: wrappedSolAmountIn should only be used for input/source token that
 *            could be SOL. This is because when SOL is the output, it is the end
 *            destination, and thus does not need to be wrapped with an amount.
 *
 * @param connection Solana connection class
 * @param ownerAddress The user's public key
 * @param tokenMint Token mint address
 * @param wrappedSolAmountIn Optional. Only use for input/source token that could be SOL
 * @param payer Payer that would pay the rent for the creation of the ATAs
 * @param modeIdempotent Optional. Use CreateIdempotent instruction instead of Create instruction
 * @param allowPDAOwnerAddress Optional. Allow PDA to be used as the ATA owner address
 * @param wrappedSolAccountCreateMethod - Optional. How to create the temporary WSOL account.
 * @returns
 */
async function resolveOrCreateATA(connection, ownerAddress, tokenMint, getAccountRentExempt, wrappedSolAmountIn = math_1.ZERO, payer = ownerAddress, modeIdempotent = false, allowPDAOwnerAddress = false, wrappedSolAccountCreateMethod = "keypair") {
    const instructions = await resolveOrCreateATAs(connection, ownerAddress, [{ tokenMint, wrappedSolAmountIn }], getAccountRentExempt, payer, modeIdempotent, allowPDAOwnerAddress, wrappedSolAccountCreateMethod);
    return instructions[0];
}
exports.resolveOrCreateATA = resolveOrCreateATA;
/**
 * IMPORTANT: wrappedSolAmountIn should only be used for input/source token that
 *            could be SOL. This is because when SOL is the output, it is the end
 *            destination, and thus does not need to be wrapped with an amount.
 *
 * @param connection Solana connection class
 * @param ownerAddress The user's public key
 * @param tokenMint Token mint address
 * @param wrappedSolAmountIn Optional. Only use for input/source token that could be SOL
 * @param payer Payer that would pay the rent for the creation of the ATAs
 * @param modeIdempotent Optional. Use CreateIdempotent instruction instead of Create instruction
 * @param allowPDAOwnerAddress Optional. Allow PDA to be used as the ATA owner address
 * @param wrappedSolAccountCreateMethod - Optional. How to create the temporary WSOL account.
 * @returns
 */
async function resolveOrCreateATAs(connection, ownerAddress, requests, getAccountRentExempt, payer = ownerAddress, modeIdempotent = false, allowPDAOwnerAddress = false, wrappedSolAccountCreateMethod = "keypair") {
    const nonNativeMints = requests.filter(({ tokenMint }) => !tokenMint.equals(spl_token_1.NATIVE_MINT));
    const nativeMints = requests.filter(({ tokenMint }) => tokenMint.equals(spl_token_1.NATIVE_MINT));
    if (nativeMints.length > 1) {
        throw new Error("Cannot resolve multiple WSolAccounts");
    }
    let instructionMap = {};
    if (nonNativeMints.length > 0) {
        const nonNativeAddresses = nonNativeMints.map(({ tokenMint }) => (0, spl_token_1.getAssociatedTokenAddressSync)(tokenMint, ownerAddress, allowPDAOwnerAddress));
        const tokenAccounts = await (0, network_1.getMultipleParsedAccounts)(connection, nonNativeAddresses, network_1.ParsableTokenAccountInfo);
        tokenAccounts.forEach((tokenAccount, index) => {
            const ataAddress = nonNativeAddresses[index];
            let resolvedInstruction;
            if (tokenAccount) {
                // ATA whose owner has been changed is abnormal entity.
                // To prevent to send swap/withdraw/collect output to the ATA, an error should be thrown.
                if (!tokenAccount.owner.equals(ownerAddress)) {
                    throw new Error(`ATA with change of ownership detected: ${ataAddress.toBase58()}`);
                }
                resolvedInstruction = { address: ataAddress, ...types_1.EMPTY_INSTRUCTION };
            }
            else {
                const createAtaInstruction = modeIdempotent
                    ? (0, spl_token_1.createAssociatedTokenAccountIdempotentInstruction)(payer, ataAddress, ownerAddress, nonNativeMints[index].tokenMint)
                    : (0, spl_token_1.createAssociatedTokenAccountInstruction)(payer, ataAddress, ownerAddress, nonNativeMints[index].tokenMint);
                resolvedInstruction = {
                    address: ataAddress,
                    instructions: [createAtaInstruction],
                    cleanupInstructions: [],
                    signers: [],
                };
            }
            instructionMap[nonNativeMints[index].tokenMint.toBase58()] = resolvedInstruction;
        });
    }
    if (nativeMints.length > 0) {
        const accountRentExempt = await getAccountRentExempt();
        const wrappedSolAmountIn = nativeMints[0]?.wrappedSolAmountIn || math_1.ZERO;
        instructionMap[spl_token_1.NATIVE_MINT.toBase58()] = token_util_1.TokenUtil.createWrappedNativeAccountInstruction(ownerAddress, wrappedSolAmountIn, accountRentExempt, payer, undefined, // use default
        wrappedSolAccountCreateMethod);
    }
    // Preserve order of resolution
    return requests.map(({ tokenMint }) => instructionMap[tokenMint.toBase58()]);
}
exports.resolveOrCreateATAs = resolveOrCreateATAs;
