"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPriorityFeeInLamports = exports.DEFAULT_MAX_PRIORITY_FEE_LAMPORTS = exports.DEFAULT_PRIORITY_FEE_PERCENTILE = exports.MICROLAMPORTS_PER_LAMPORT = void 0;
exports.MICROLAMPORTS_PER_LAMPORT = 1000000;
exports.DEFAULT_PRIORITY_FEE_PERCENTILE = 0.9;
exports.DEFAULT_MAX_PRIORITY_FEE_LAMPORTS = 1000000; // 0.001 SOL
async function getPriorityFeeInLamports(connection, computeBudgetLimit, instructions, percentile) {
    const recentPriorityFees = await connection.getRecentPrioritizationFees({
        lockedWritableAccounts: getLockWritableAccounts(instructions),
    });
    const priorityFee = getPriorityFeeSuggestion(recentPriorityFees, percentile);
    return (priorityFee * computeBudgetLimit) / exports.MICROLAMPORTS_PER_LAMPORT;
}
exports.getPriorityFeeInLamports = getPriorityFeeInLamports;
function getPriorityFeeSuggestion(recentPriorityFees, percentile) {
    // Take the Xth percentile of all the slots returned
    const sortedPriorityFees = recentPriorityFees
        .sort((a, b) => a.prioritizationFee - b.prioritizationFee);
    const percentileIndex = Math.min(Math.max(Math.floor(sortedPriorityFees.length * percentile), 0), sortedPriorityFees.length - 1);
    return sortedPriorityFees[percentileIndex].prioritizationFee;
}
function getLockWritableAccounts(instructions) {
    const accountKeys = instructions
        .flatMap((instruction) => [...instruction.instructions, ...instruction.cleanupInstructions])
        .flatMap((instruction) => instruction.keys);
    const writableAccounts = accountKeys.filter((key) => key.isWritable).map((key) => key.pubkey);
    return Array.from(new Set(writableAccounts));
}
