"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isVersionedTransaction = exports.TransactionBuilder = exports.defaultTransactionBuilderOptions = void 0;
const web3_js_1 = require("@solana/web3.js");
const constants_1 = require("./constants");
const compute_budget_1 = require("./compute-budget");
const DEFAULT_MAX_COMPUTE_UNIT_LIMIT = 1400000;
const LEGACY_TX_UNIQUE_KEYS_LIMIT = 35;
exports.defaultTransactionBuilderOptions = {
    defaultBuildOption: {
        maxSupportedTransactionVersion: 0,
        blockhashCommitment: "confirmed",
    },
    defaultSendOption: {
        skipPreflight: false,
        preflightCommitment: "confirmed",
        maxRetries: 3,
    },
    defaultConfirmationCommitment: "confirmed",
};
/**
 * Transaction builder for composing, building and sending transactions.
 * @category Transactions
 */
class TransactionBuilder {
    constructor(connection, wallet, defaultOpts) {
        this.connection = connection;
        this.wallet = wallet;
        this.instructions = [];
        this.signers = [];
        this.opts = defaultOpts ?? exports.defaultTransactionBuilderOptions;
    }
    /**
     * Append an instruction into this builder.
     * @param instruction - An Instruction
     * @returns Returns this transaction builder.
     */
    addInstruction(instruction) {
        this.instructions.push(instruction);
        return this;
    }
    /**
     * Append a list of instructions into this builder.
     * @param instructions - A list of Instructions
     * @returns Returns this transaction builder.
     */
    addInstructions(instructions) {
        this.instructions = this.instructions.concat(instructions);
        return this;
    }
    /**
     * Prepend a list of instructions into this builder.
     * @param instruction - An Instruction
     * @returns Returns this transaction builder.
     */
    prependInstruction(instruction) {
        this.instructions.unshift(instruction);
        return this;
    }
    /**
     * Prepend a list of instructions into this builder.
     * @param instructions - A list of Instructions
     * @returns Returns this transaction builder.
     */
    prependInstructions(instructions) {
        this.instructions = instructions.concat(this.instructions);
        return this;
    }
    addSigner(signer) {
        this.signers.push(signer);
        return this;
    }
    /**
     * Checks whether this builder contains any instructions.
     * @returns Whether this builder contains any instructions.
     */
    isEmpty() {
        return this.instructions.length == 0;
    }
    /**
     * Compresses all instructions & signers in this builder
     * into one single instruction
     * @param compressPost Compress all post instructions into the instructions field
     * @returns Instruction object containing all
     */
    compressIx(compressPost) {
        let instructions = [];
        let cleanupInstructions = [];
        let signers = [];
        this.instructions.forEach((curr) => {
            instructions = instructions.concat(curr.instructions);
            // Cleanup instructions should execute in reverse order
            cleanupInstructions = curr.cleanupInstructions.concat(cleanupInstructions);
            signers = signers.concat(curr.signers);
        });
        if (compressPost) {
            instructions = instructions.concat(cleanupInstructions);
            cleanupInstructions = [];
        }
        return {
            instructions: [...instructions],
            cleanupInstructions: [...cleanupInstructions],
            signers,
        };
    }
    /**
     * Returns the size of the current transaction in bytes. Measurement method can differ based on the maxSupportedTransactionVersion.
     * @param userOptions - Options to override the default build options
     * @returns the size of the current transaction in bytes.
     * @throws error if there is an error measuring the transaction size.
     *         This can happen if the transaction is too large, or if the transaction contains too many keys to be serialized.
     */
    txnSize(userOptions) {
        const finalOptions = {
            ...this.opts.defaultBuildOption,
            ...userOptions,
            latestBlockhash: constants_1.MEASUREMENT_BLOCKHASH,
            computeBudgetOption: this.opts.defaultBuildOption.computeBudgetOption ?? { type: "none" },
        };
        if (this.isEmpty()) {
            return 0;
        }
        const request = this.buildSync(finalOptions);
        const tx = request.transaction;
        return (0, exports.isVersionedTransaction)(tx) ? measureV0Tx(tx) : measureLegacyTx(tx);
    }
    /**
     * Constructs a transaction payload with the gathered instructions synchronously
     * @param options - Options used to build the transaction
     * @returns a TransactionPayload object that can be excuted or agregated into other transactions
     */
    buildSync(options) {
        const { latestBlockhash, maxSupportedTransactionVersion, computeBudgetOption } = options;
        const ix = this.compressIx(true);
        let prependInstructions = [];
        if (computeBudgetOption.type === "fixed") {
            const computeLimit = computeBudgetOption.computeBudgetLimit ?? DEFAULT_MAX_COMPUTE_UNIT_LIMIT;
            const microLamports = Math.floor((computeBudgetOption.priorityFeeLamports * compute_budget_1.MICROLAMPORTS_PER_LAMPORT) / computeLimit);
            prependInstructions = [
                web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
                    units: computeLimit,
                }),
                web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                    microLamports,
                })
            ];
        }
        if (computeBudgetOption.type === "auto") {
            // Auto only works using `build` so when we encounter `auto` here we
            // just use the use 0 priority budget and default compute budget.
            // This should only be happening for calucling the tx size so it should be fine.
            prependInstructions = [
                web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
                    units: computeBudgetOption.computeBudgetLimit ?? DEFAULT_MAX_COMPUTE_UNIT_LIMIT,
                }),
                web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                    microLamports: 0,
                })
            ];
        }
        const allSigners = ix.signers.concat(this.signers);
        const recentBlockhash = latestBlockhash;
        if (maxSupportedTransactionVersion === "legacy") {
            const transaction = new web3_js_1.Transaction({
                ...recentBlockhash,
                feePayer: this.wallet.publicKey,
            });
            if (prependInstructions.length > 0) {
                transaction.add(...prependInstructions);
            }
            transaction.add(...ix.instructions);
            transaction.feePayer = this.wallet.publicKey;
            return {
                transaction: transaction,
                signers: allSigners,
                recentBlockhash,
            };
        }
        const txnMsg = new web3_js_1.TransactionMessage({
            recentBlockhash: recentBlockhash.blockhash,
            payerKey: this.wallet.publicKey,
            instructions: ix.instructions,
        });
        const { lookupTableAccounts } = options;
        const msg = txnMsg.compileToV0Message(lookupTableAccounts);
        const v0txn = new web3_js_1.VersionedTransaction(msg);
        return {
            transaction: v0txn,
            signers: allSigners,
            recentBlockhash,
        };
    }
    /**
     * Constructs a transaction payload with the gathered instructions
     * @param userOptions - Options to override the default build options
     * @returns a TransactionPayload object that can be excuted or agregated into other transactions
     */
    async build(userOptions) {
        const finalOptions = { ...this.opts.defaultBuildOption, ...userOptions };
        const { latestBlockhash, blockhashCommitment, computeBudgetOption } = finalOptions;
        let recentBlockhash = latestBlockhash;
        if (!recentBlockhash) {
            recentBlockhash = await this.connection.getLatestBlockhash(blockhashCommitment);
        }
        let finalComputeBudgetOption = computeBudgetOption ?? { type: "none" };
        if (finalComputeBudgetOption.type === "auto") {
            const computeBudgetLimit = finalComputeBudgetOption.computeBudgetLimit ?? DEFAULT_MAX_COMPUTE_UNIT_LIMIT;
            const percentile = finalComputeBudgetOption.percentile ?? compute_budget_1.DEFAULT_PRIORITY_FEE_PERCENTILE;
            const priorityFee = await (0, compute_budget_1.getPriorityFeeInLamports)(this.connection, computeBudgetLimit, this.instructions, percentile);
            const maxPriorityFeeLamports = finalComputeBudgetOption.maxPriorityFeeLamports ?? compute_budget_1.DEFAULT_MAX_PRIORITY_FEE_LAMPORTS;
            const priorityFeeLamports = Math.min(priorityFee, maxPriorityFeeLamports);
            finalComputeBudgetOption = {
                type: "fixed",
                priorityFeeLamports,
                computeBudgetLimit
            };
        }
        return this.buildSync({ ...finalOptions, latestBlockhash: recentBlockhash, computeBudgetOption: finalComputeBudgetOption });
    }
    /**
     * Constructs a transaction payload with the gathered instructions, sign it with the provider and send it out
     * @param options - Options to build the transaction. . Overrides the default options provided in the constructor.
     * @param sendOptions - Options to send the transaction. Overrides the default options provided in the constructor.
     * @param confirmCommitment - Commitment level to wait for transaction confirmation. Overrides the default options provided in the constructor.
     * @returns the txId of the transaction
     */
    async buildAndExecute(options, sendOptions, confirmCommitment) {
        const sendOpts = { ...this.opts.defaultSendOption, ...sendOptions };
        const btx = await this.build(options);
        const txn = btx.transaction;
        const resolvedConfirmCommitment = confirmCommitment ?? this.opts.defaultConfirmationCommitment;
        let txId;
        if ((0, exports.isVersionedTransaction)(txn)) {
            const signedTxn = await this.wallet.signTransaction(txn);
            signedTxn.sign(btx.signers);
            txId = await this.connection.sendTransaction(signedTxn, sendOpts);
        }
        else {
            const signedTxn = await this.wallet.signTransaction(txn);
            btx.signers
                .filter((s) => s !== undefined)
                .forEach((keypair) => signedTxn.partialSign(keypair));
            txId = await this.connection.sendRawTransaction(signedTxn.serialize(), sendOpts);
        }
        const result = await this.connection.confirmTransaction({
            signature: txId,
            ...btx.recentBlockhash,
        }, resolvedConfirmCommitment);
        const confirmTxErr = result.value.err;
        if (confirmTxErr) {
            throw new Error(confirmTxErr.toString());
        }
        return txId;
    }
}
exports.TransactionBuilder = TransactionBuilder;
/**
 * Checks if a transaction is a versioned transaction.
 * @param tx Transaction to check.
 * @returns True if the transaction is a versioned transaction.
 */
const isVersionedTransaction = (tx) => {
    return "version" in tx;
};
exports.isVersionedTransaction = isVersionedTransaction;
function measureLegacyTx(tx) {
    // Due to the high cost of serialize, if the number of unique accounts clearly exceeds the limit of legacy transactions,
    // serialize is not performed and a determination of infeasibility is made.
    const uniqueKeys = new Set();
    for (const instruction of tx.instructions) {
        for (const key of instruction.keys) {
            uniqueKeys.add(key.pubkey.toBase58());
        }
        uniqueKeys.add(instruction.programId.toBase58());
    }
    if (uniqueKeys.size > LEGACY_TX_UNIQUE_KEYS_LIMIT) {
        throw new Error("Unable to measure transaction size. Too many unique keys in transaction.");
    }
    try {
        // (Legacy)Transaction.serialize ensures that the size of successfully serialized data
        // is less than or equal to PACKET_DATA_SIZE(1232).
        // https://github.com/solana-labs/solana-web3.js/blob/77f78a8/packages/library-legacy/src/transaction/legacy.ts#L806
        const serialized = tx.serialize({ requireAllSignatures: false });
        return serialized.length;
    }
    catch (e) {
        throw new Error("Unable to measure transaction size. Unable to serialize transaction.");
    }
}
function measureV0Tx(tx) {
    let serialized;
    try {
        serialized = tx.serialize();
    }
    catch (e) {
        throw new Error("Unable to measure transaction size. Unable to serialize transaction.");
    }
    // VersionedTransaction.serialize does NOT ensures that the size of successfully serialized data is
    // less than or equal to PACKET_DATA_SIZE(1232).
    // https://github.com/solana-labs/solana-web3.js/blob/77f78a8/packages/library-legacy/src/transaction/versioned.ts#L65
    //
    // BufferLayout.encode throws an error for writes that exceed the buffer size,
    // so obviously large transactions will throws an error.
    // However, depending on the size of the signature and message body, a size between 1233 - 2048 may be returned
    // as a successful result, so we need to check it here.
    if (serialized.length > web3_js_1.PACKET_DATA_SIZE) {
        throw new Error("Unable to measure transaction size. Transaction too large.");
    }
    return serialized.length;
}
const toBuffer = (arr) => {
    if (Buffer.isBuffer(arr)) {
        return arr;
    }
    else if (arr instanceof Uint8Array) {
        return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    else {
        return Buffer.from(arr);
    }
};
