"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenUtil = void 0;
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const sha256_1 = require("@noble/hashes/sha256");
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const math_1 = require("../math");
const web3_1 = require("../web3");
/**
 * @category Util
 */
class TokenUtil {
    static isNativeMint(mint) {
        return mint.equals(spl_token_1.NATIVE_MINT);
    }
    /**
     * Create an ix to send a native-mint and unwrap it to the user's wallet.
     * @param owner - PublicKey for the owner of the temporary WSOL account.
     * @param amountIn - Amount of SOL to wrap.
     * @param rentExemptLamports - Rent exempt lamports for the temporary WSOL account.
     * @param payer - PublicKey for the payer that would fund the temporary WSOL accounts. (must sign the txn)
     * @param unwrapDestination - PublicKey for the receiver that would receive the unwrapped SOL including rent.
     * @param createAccountMethod - How to create the temporary WSOL account.
     * @returns
     */
    static createWrappedNativeAccountInstruction(owner, amountIn, rentExemptLamports, payer, unwrapDestination, createAccountMethod = "keypair") {
        const payerKey = payer ?? owner;
        const unwrapDestinationKey = unwrapDestination ?? owner;
        switch (createAccountMethod) {
            case "ata":
                return createWrappedNativeAccountInstructionWithATA(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey);
            case "keypair":
                return createWrappedNativeAccountInstructionWithKeypair(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey);
            case "withSeed":
                return createWrappedNativeAccountInstructionWithSeed(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey);
            default:
                throw new Error(`Invalid createAccountMethod: ${createAccountMethod}`);
        }
    }
    /**
     * Create an ix to send a spl-token / native-mint to another wallet.
     * This function will handle the associated token accounts internally for spl-token.
     * SOL is sent directly to the user's wallet.
     *
     * @param connection - Connection object
     * @param sourceWallet - PublicKey for the sender's wallet
     * @param destinationWallet - PublicKey for the receiver's wallet
     * @param tokenMint - Mint for the token that is being sent.
     * @param tokenDecimals - Decimal for the token that is being sent.
     * @param amount - Amount of token to send
     * @param getAccountRentExempt - Fn to fetch the account rent exempt value
     * @param payer - PublicKey for the payer that would fund the possibly new token-accounts. (must sign the txn)
     * @param allowPDASourceWallet - Allow PDA to be used as the source wallet.
     * @returns
     */
    static async createSendTokensToWalletInstruction(connection, sourceWallet, destinationWallet, tokenMint, tokenDecimals, amount, getAccountRentExempt, payer, allowPDASourceWallet = false) {
        (0, tiny_invariant_1.default)(!amount.eq(math_1.ZERO), "SendToken transaction must send more than 0 tokens.");
        // Specifically handle SOL, which is not a spl-token.
        if (tokenMint.equals(spl_token_1.NATIVE_MINT)) {
            const sendSolTxn = web3_js_1.SystemProgram.transfer({
                fromPubkey: sourceWallet,
                toPubkey: destinationWallet,
                lamports: BigInt(amount.toString()),
            });
            return {
                instructions: [sendSolTxn],
                cleanupInstructions: [],
                signers: [],
            };
        }
        const sourceTokenAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(tokenMint, sourceWallet, allowPDASourceWallet);
        const { address: destinationTokenAccount, ...destinationAtaIx } = await (0, web3_1.resolveOrCreateATA)(connection, destinationWallet, tokenMint, getAccountRentExempt, amount, payer, undefined, true);
        const transferIx = (0, spl_token_1.createTransferCheckedInstruction)(sourceTokenAccount, tokenMint, destinationTokenAccount, sourceWallet, BigInt(amount.toString()), tokenDecimals);
        return {
            instructions: destinationAtaIx.instructions.concat(transferIx),
            cleanupInstructions: destinationAtaIx.cleanupInstructions,
            signers: destinationAtaIx.signers,
        };
    }
}
exports.TokenUtil = TokenUtil;
function createWrappedNativeAccountInstructionWithATA(owner, amountIn, _rentExemptLamports, payerKey, unwrapDestinationKey) {
    const tempAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(spl_token_1.NATIVE_MINT, owner);
    const instructions = [
        (0, spl_token_1.createAssociatedTokenAccountIdempotentInstruction)(payerKey, tempAccount, owner, spl_token_1.NATIVE_MINT)
    ];
    if (amountIn.gt(math_1.ZERO)) {
        instructions.push(web3_js_1.SystemProgram.transfer({
            fromPubkey: payerKey,
            toPubkey: tempAccount,
            lamports: amountIn.toNumber(),
        }));
        instructions.push((0, spl_token_1.createSyncNativeInstruction)(tempAccount));
    }
    const closeWSOLAccountInstruction = (0, spl_token_1.createCloseAccountInstruction)(tempAccount, unwrapDestinationKey, owner);
    return {
        address: tempAccount,
        instructions,
        cleanupInstructions: [closeWSOLAccountInstruction],
        signers: [],
    };
}
function createWrappedNativeAccountInstructionWithKeypair(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey) {
    const tempAccount = new web3_js_1.Keypair();
    const createAccountInstruction = web3_js_1.SystemProgram.createAccount({
        fromPubkey: payerKey,
        newAccountPubkey: tempAccount.publicKey,
        lamports: amountIn.toNumber() + rentExemptLamports,
        space: spl_token_1.AccountLayout.span,
        programId: spl_token_1.TOKEN_PROGRAM_ID,
    });
    const initAccountInstruction = (0, spl_token_1.createInitializeAccountInstruction)(tempAccount.publicKey, spl_token_1.NATIVE_MINT, owner);
    const closeWSOLAccountInstruction = (0, spl_token_1.createCloseAccountInstruction)(tempAccount.publicKey, unwrapDestinationKey, owner);
    return {
        address: tempAccount.publicKey,
        instructions: [createAccountInstruction, initAccountInstruction],
        cleanupInstructions: [closeWSOLAccountInstruction],
        signers: [tempAccount],
    };
}
function createWrappedNativeAccountInstructionWithSeed(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey) {
    // seed is always shorter than a signature.
    // So createWrappedNativeAccountInstructionWithSeed always generates small size instructions
    // than createWrappedNativeAccountInstructionWithKeypair.
    const seed = web3_js_1.Keypair.generate().publicKey.toBase58().slice(0, 32); // 32 chars
    const tempAccount = (() => {
        // same to PublicKey.createWithSeed, but this one is synchronous
        const fromPublicKey = owner;
        const programId = spl_token_1.TOKEN_PROGRAM_ID;
        const buffer = Buffer.concat([
            fromPublicKey.toBuffer(),
            Buffer.from(seed),
            programId.toBuffer(),
        ]);
        const publicKeyBytes = (0, sha256_1.sha256)(buffer);
        return new web3_js_1.PublicKey(publicKeyBytes);
    })();
    const createAccountInstruction = web3_js_1.SystemProgram.createAccountWithSeed({
        fromPubkey: payerKey,
        basePubkey: owner,
        seed,
        newAccountPubkey: tempAccount,
        lamports: amountIn.toNumber() + rentExemptLamports,
        space: spl_token_1.AccountLayout.span,
        programId: spl_token_1.TOKEN_PROGRAM_ID,
    });
    const initAccountInstruction = (0, spl_token_1.createInitializeAccountInstruction)(tempAccount, spl_token_1.NATIVE_MINT, owner);
    const closeWSOLAccountInstruction = (0, spl_token_1.createCloseAccountInstruction)(tempAccount, unwrapDestinationKey, owner);
    return {
        address: tempAccount,
        instructions: [createAccountInstruction, initAccountInstruction],
        cleanupInstructions: [closeWSOLAccountInstruction],
        signers: [],
    };
}
