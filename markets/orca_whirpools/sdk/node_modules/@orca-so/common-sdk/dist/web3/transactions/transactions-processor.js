"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionProcessor = void 0;
const transactions_builder_1 = require("./transactions-builder");
/**
 * @deprecated
 */
class TransactionProcessor {
    constructor(connection, wallet, commitment = "confirmed") {
        this.connection = connection;
        this.wallet = wallet;
        this.commitment = commitment;
    }
    async signTransaction(txRequest) {
        const { transactions, lastValidBlockHeight, blockhash } = await this.signTransactions([
            txRequest,
        ]);
        return { transaction: transactions[0], lastValidBlockHeight, blockhash };
    }
    async signTransactions(txRequests) {
        const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash(this.commitment);
        const feePayer = this.wallet.publicKey;
        const pSignedTxs = txRequests.map((txRequest) => {
            return rewriteTransaction(txRequest, feePayer, blockhash);
        });
        const transactions = await this.wallet.signAllTransactions(pSignedTxs);
        return {
            transactions,
            lastValidBlockHeight,
            blockhash,
        };
    }
    async sendTransaction(transaction, lastValidBlockHeight, blockhash) {
        const execute = this.constructSendTransactions([transaction], lastValidBlockHeight, blockhash);
        const txs = await execute();
        const ex = txs[0];
        if (ex.status === "fulfilled") {
            return ex.value;
        }
        else {
            throw ex.reason;
        }
    }
    constructSendTransactions(transactions, lastValidBlockHeight, blockhash, parallel = true) {
        const executeTx = async (tx) => {
            const rawTxs = tx.serialize();
            return this.connection.sendRawTransaction(rawTxs, {
                preflightCommitment: this.commitment,
            });
        };
        const confirmTx = async (txId) => {
            const result = await this.connection.confirmTransaction({
                signature: txId,
                lastValidBlockHeight: lastValidBlockHeight,
                blockhash,
            }, this.commitment);
            if (result.value.err) {
                throw new Error(`Transaction failed: ${JSON.stringify(result.value)}`);
            }
        };
        return async () => {
            if (parallel) {
                const results = transactions.map(async (tx) => {
                    const txId = await executeTx(tx);
                    await confirmTx(txId);
                    return txId;
                });
                return Promise.allSettled(results);
            }
            else {
                const results = [];
                for (const tx of transactions) {
                    const txId = await executeTx(tx);
                    await confirmTx(txId);
                    results.push(txId);
                }
                return Promise.allSettled(results);
            }
        };
    }
    async signAndConstructTransaction(txRequest) {
        const { transaction, lastValidBlockHeight, blockhash } = await this.signTransaction(txRequest);
        return {
            signedTx: transaction,
            execute: async () => this.sendTransaction(transaction, lastValidBlockHeight, blockhash),
        };
    }
    async signAndConstructTransactions(txRequests, parallel = true) {
        const { transactions, lastValidBlockHeight, blockhash } = await this.signTransactions(txRequests);
        const execute = this.constructSendTransactions(transactions, lastValidBlockHeight, blockhash, parallel);
        return { signedTxs: transactions, execute };
    }
}
exports.TransactionProcessor = TransactionProcessor;
function rewriteTransaction(txRequest, feePayer, blockhash) {
    if ((0, transactions_builder_1.isVersionedTransaction)(txRequest.transaction)) {
        let tx = txRequest.transaction;
        if (txRequest.signers) {
            tx.sign(txRequest.signers ?? []);
        }
        return tx;
    }
    else {
        let tx = txRequest.transaction;
        let signers = txRequest.signers ?? [];
        tx.feePayer = feePayer;
        tx.recentBlockhash = blockhash;
        signers.forEach((kp) => {
            tx.partialSign(kp);
        });
        return tx;
    }
}
