"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMultipleAccounts = exports.getMultipleAccountsInMap = exports.getMultipleParsedAccounts = exports.getParsedAccount = void 0;
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const address_util_1 = require("../address-util");
async function getParsedAccount(connection, address, parser) {
    const value = await connection.getAccountInfo(address_util_1.AddressUtil.toPubKey(address));
    const key = address_util_1.AddressUtil.toPubKey(address);
    return parser.parse(key, value);
}
exports.getParsedAccount = getParsedAccount;
async function getMultipleParsedAccounts(connection, addresses, parser, chunkSize = 100) {
    if (addresses.length === 0) {
        return [];
    }
    const values = await getMultipleAccounts(connection, address_util_1.AddressUtil.toPubKeys(addresses), 10, chunkSize);
    const results = values.map((val) => {
        if (val[1] === null) {
            return null;
        }
        return parser.parse(val[0], val[1]);
    });
    (0, tiny_invariant_1.default)(results.length === addresses.length, "not enough results fetched");
    return results;
}
exports.getMultipleParsedAccounts = getMultipleParsedAccounts;
async function getMultipleAccountsInMap(connection, addresses, timeoutAfterSeconds = 10, chunkSize = 100) {
    const results = await getMultipleAccounts(connection, addresses, timeoutAfterSeconds, chunkSize);
    return results.reduce((map, [key, value]) => {
        map.set(key.toBase58(), value);
        return map;
    }, new Map());
}
exports.getMultipleAccountsInMap = getMultipleAccountsInMap;
async function getMultipleAccounts(connection, addresses, timeoutAfterSeconds = 10, chunkSize = 100) {
    if (addresses.length === 0) {
        return [];
    }
    const promises = [];
    const chunks = Math.ceil(addresses.length / chunkSize);
    const result = new Array(chunks);
    for (let i = 0; i < result.length; i++) {
        const slice = addresses.slice(i * chunkSize, (i + 1) * chunkSize);
        const addressChunk = address_util_1.AddressUtil.toPubKeys(slice);
        const promise = new Promise(async (resolve) => {
            const res = await connection.getMultipleAccountsInfo(addressChunk);
            const fetchedAccountChunk = res.map((result, index) => {
                return [addressChunk[index], result];
            });
            result[i] = fetchedAccountChunk;
            resolve();
        });
        promises.push(promise);
    }
    await Promise.race([
        Promise.all(promises),
        timeoutAfter(timeoutAfterSeconds, "connection.getMultipleAccountsInfo timeout"),
    ]);
    const flattenedResult = result.flat();
    (0, tiny_invariant_1.default)(flattenedResult.length === addresses.length, "getMultipleAccounts not enough results");
    return flattenedResult;
}
exports.getMultipleAccounts = getMultipleAccounts;
function timeoutAfter(seconds, message) {
    return new Promise((_, reject) => {
        setTimeout(() => {
            reject(new Error(message));
        }, seconds * 1000);
    });
}
