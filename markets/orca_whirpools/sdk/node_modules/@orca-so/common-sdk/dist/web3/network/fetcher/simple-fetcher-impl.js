"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleAccountFetcher = void 0;
const address_util_1 = require("../../address-util");
const account_requests_1 = require("../account-requests");
// SimpleAccountFetcher is a simple implementation of AccountCache that stores the fetched
// accounts in memory. If TTL is not provided, it will use TTL defined in the the retention policy
// for the parser. If that is also not provided, the request will always prefer the cache value.
class SimpleAccountFetcher {
    constructor(connection, retentionPolicy) {
        this.connection = connection;
        this.retentionPolicy = retentionPolicy;
        this.cache = new Map();
        this.cache = new Map();
    }
    async getAccount(address, parser, opts, now = Date.now()) {
        const addressKey = address_util_1.AddressUtil.toPubKey(address);
        const addressStr = address_util_1.AddressUtil.toString(address);
        const cached = this.cache.get(addressStr);
        const maxAge = this.getMaxAge(this.retentionPolicy.get(parser), opts);
        const elapsed = !!cached ? now - (cached?.fetchedAt ?? 0) : Number.NEGATIVE_INFINITY;
        const expired = elapsed > maxAge;
        if (!!cached && !expired) {
            return cached.value;
        }
        try {
            const accountInfo = await this.connection.getAccountInfo(addressKey);
            const value = parser.parse(addressKey, accountInfo);
            this.cache.set(addressStr, { parser, value, fetchedAt: now });
            return value;
        }
        catch (e) {
            this.cache.set(addressStr, { parser, value: null, fetchedAt: now });
            return null;
        }
    }
    getMaxAge(parserMaxAge, opts) {
        if (opts?.maxAge !== undefined) {
            return opts.maxAge;
        }
        return parserMaxAge === undefined ? Number.POSITIVE_INFINITY : parserMaxAge;
    }
    async getAccounts(addresses, parser, opts, now = Date.now()) {
        const addressStrs = address_util_1.AddressUtil.toStrings(addresses);
        await this.fetchAndPopulateCache(addressStrs, parser, opts, now);
        // Build a map of the results, insert by the order of the addresses parameter
        const result = new Map();
        addressStrs.forEach((addressStr) => {
            const cached = this.cache.get(addressStr);
            const value = cached?.value;
            result.set(addressStr, value);
        });
        return result;
    }
    async getAccountsAsArray(addresses, parser, opts, now = Date.now()) {
        const addressStrs = address_util_1.AddressUtil.toStrings(addresses);
        await this.fetchAndPopulateCache(addressStrs, parser, opts, now);
        // Rebuild an array containing the results, insert by the order of the addresses parameter
        const result = new Array();
        addressStrs.forEach((addressStr) => {
            const cached = this.cache.get(addressStr);
            const value = cached?.value;
            result.push(value);
        });
        return result;
    }
    populateAccounts(accounts, parser, now) {
        Array.from(accounts.entries()).forEach(([key, value]) => {
            this.cache.set(key, { parser, value, fetchedAt: now });
        });
    }
    async refreshAll(now = Date.now()) {
        const addresses = Array.from(this.cache.keys());
        const fetchedAccountsMap = await (0, account_requests_1.getMultipleAccountsInMap)(this.connection, addresses);
        for (const [key, cachedContent] of this.cache.entries()) {
            const parser = cachedContent.parser;
            const fetchedEntry = fetchedAccountsMap.get(key);
            const value = parser.parse(address_util_1.AddressUtil.toPubKey(key), fetchedEntry);
            this.cache.set(key, { parser, value, fetchedAt: now });
        }
    }
    async fetchAndPopulateCache(addresses, parser, opts, now = Date.now()) {
        const addressStrs = address_util_1.AddressUtil.toStrings(addresses);
        const maxAge = this.getMaxAge(this.retentionPolicy.get(parser), opts);
        // Filter out all unexpired accounts to get the accounts to fetch
        const undefinedAccounts = addressStrs.filter((addressStr) => {
            const cached = this.cache.get(addressStr);
            const elapsed = !!cached ? now - (cached?.fetchedAt ?? 0) : Number.NEGATIVE_INFINITY;
            const expired = elapsed > maxAge;
            return !cached || expired;
        });
        // Fetch all undefined accounts and place in cache
        // TODO: We currently do not support contextSlot consistency across the batched getMultipleAccounts call
        // If the addresses list contain accounts in the 1st gMA call as subsequent calls and the gMA returns on different contextSlots,
        // the returned results can be inconsistent and unexpected by the user.
        if (undefinedAccounts.length > 0) {
            const fetchedAccountsMap = await (0, account_requests_1.getMultipleAccountsInMap)(this.connection, undefinedAccounts);
            undefinedAccounts.forEach((key) => {
                const fetchedEntry = fetchedAccountsMap.get(key);
                const value = parser.parse(address_util_1.AddressUtil.toPubKey(key), fetchedEntry);
                this.cache.set(key, { parser, value, fetchedAt: now });
            });
        }
    }
}
exports.SimpleAccountFetcher = SimpleAccountFetcher;
